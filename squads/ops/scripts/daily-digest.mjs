#!/usr/bin/env node
/**
 * Daily Digest - Batch processing of activity logs
 *
 * Runs end-of-day to:
 * 1. Summarize day's activities (Ollama local = â‚¬0)
 * 2. Extract decisions â†’ .aios/memory/decisions/
 * 3. Extract patterns â†’ .aios/learning/patterns/
 * 4. Update metrics
 *
 * Usage:
 *   node daily-digest.mjs [--date=2025-02-12] [--dry-run]
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync, spawn } from 'child_process';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, '../../..');

const PATHS = {
  activityLogs: path.join(ROOT, '.aios/logs/activity'),
  digests: path.join(ROOT, '.aios/logs/digests'),
  decisions: path.join(ROOT, '.aios/memory/decisions'),
  patterns: path.join(ROOT, '.aios/learning/patterns'),
  metrics: path.join(ROOT, '.aios/learning/metrics')
};

// Ensure directories exist
Object.values(PATHS).forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

async function loadActivityLog(date) {
  const logFile = path.join(PATHS.activityLogs, `${date}.jsonl`);
  if (!fs.existsSync(logFile)) {
    return [];
  }
  const lines = fs.readFileSync(logFile, 'utf-8').split('\n').filter(Boolean);
  return lines.map(line => JSON.parse(line));
}

function extractDecisions(entries) {
  return entries.filter(e =>
    e.type === 'decision' ||
    e.tags.includes('auto-detected-decision')
  );
}

function extractErrors(entries) {
  return entries.filter(e =>
    e.type === 'error' ||
    e.tags.includes('auto-detected-error')
  );
}

function extractPatterns(entries) {
  // Deterministic pattern detection (no AI needed)
  const patterns = [];

  // Group by type and look for repetitions
  const actionCounts = {};
  entries.forEach(e => {
    const key = e.action.toLowerCase().split(' ').slice(0, 3).join(' ');
    actionCounts[key] = (actionCounts[key] || 0) + 1;
  });

  // Actions done 2+ times might be patterns
  Object.entries(actionCounts).forEach(([action, count]) => {
    if (count >= 2) {
      patterns.push({
        type: 'repetition',
        action: action,
        count: count,
        confidence: Math.min(0.5 + (count * 0.1), 0.9)
      });
    }
  });

  return patterns;
}

async function summarizeWithOllama(entries) {
  // For now, always use deterministic summary (more reliable, zero cost)
  // Ollama can be enabled later when prompt tuning is done
  return generateDeterministicSummary(entries);
}

function generateDeterministicSummary(entries) {
  const byType = {};
  entries.forEach(e => {
    byType[e.type] = (byType[e.type] || 0) + 1;
  });

  const summary = [];
  if (byType.decision) summary.push(`${byType.decision} decisÃµes tomadas`);
  if (byType.implementation) summary.push(`${byType.implementation} implementaÃ§Ãµes`);
  if (byType.error) summary.push(`${byType.error} erros/fixes`);
  if (byType.action) summary.push(`${byType.action} aÃ§Ãµes gerais`);

  const files = [...new Set(entries.flatMap(e => e.files))];
  if (files.length) summary.push(`Arquivos: ${files.slice(0, 5).join(', ')}`);

  return summary.join('\n');
}

function generateDigest(date, entries, summary, decisions, errors, patterns) {
  return `# Daily Digest - ${date}

## Summary
${summary}

## Statistics
- Total entries: ${entries.length}
- Decisions: ${decisions.length}
- Errors/Fixes: ${errors.length}
- Patterns detected: ${patterns.length}

## Decisions
${decisions.length ? decisions.map(d => `- ${d.action}`).join('\n') : '_None_'}

## Errors/Fixes
${errors.length ? errors.map(e => `- ${e.action}`).join('\n') : '_None_'}

## Patterns Detected
${patterns.length ? patterns.map(p => `- ${p.action} (${p.count}x, confidence: ${p.confidence})`).join('\n') : '_None_'}

## Files Touched
${[...new Set(entries.flatMap(e => e.files))].join('\n') || '_None_'}

---
*Generated by daily-digest.mjs*
`;
}

async function updateDecisionsIndex(decisions, date) {
  const indexPath = path.join(PATHS.decisions, 'index.yaml');
  if (!fs.existsSync(indexPath)) return;

  let content = fs.readFileSync(indexPath, 'utf-8');

  // Update last_updated
  content = content.replace(
    /last_updated: "[^"]+"/,
    `last_updated: "${date}"`
  );

  // Count existing entries
  const countMatch = content.match(/total_entries: (\d+)/);
  const currentCount = countMatch ? parseInt(countMatch[1]) : 0;

  content = content.replace(
    /total_entries: \d+/,
    `total_entries: ${currentCount + decisions.length}`
  );

  fs.writeFileSync(indexPath, content);
}

async function updateLearningMetrics(entries, patterns, date) {
  const metricsPath = path.join(PATHS.metrics, 'learning-effectiveness.yaml');
  if (!fs.existsSync(metricsPath)) return;

  let content = fs.readFileSync(metricsPath, 'utf-8');

  // Update last_updated
  content = content.replace(
    /last_updated: "[^"]+"/,
    `last_updated: "${date}"`
  );

  // Update patterns count
  const patternsMatch = content.match(/total_patterns: (\d+)/);
  const currentPatterns = patternsMatch ? parseInt(patternsMatch[1]) : 0;

  content = content.replace(
    /total_patterns: (\d+)/,
    `total_patterns: ${currentPatterns + patterns.length}`
  );

  fs.writeFileSync(metricsPath, content);
}

async function run(options = {}) {
  const date = options.date || new Date().toISOString().split('T')[0];
  const dryRun = options.dryRun || false;

  console.log(`\nðŸ“Š Daily Digest - ${date}`);
  console.log('â”€'.repeat(50));

  // Load activity log
  const entries = await loadActivityLog(date);
  if (entries.length === 0) {
    console.log('No activity logged for this date.');
    return;
  }

  console.log(`Loaded ${entries.length} entries`);

  // Extract components
  const decisions = extractDecisions(entries);
  const errors = extractErrors(entries);
  const patterns = extractPatterns(entries);

  console.log(`Found: ${decisions.length} decisions, ${errors.length} errors, ${patterns.length} patterns`);

  // Generate summary (Ollama or fallback)
  console.log('Generating summary...');
  const summary = await summarizeWithOllama(entries);

  // Generate digest
  const digest = generateDigest(date, entries, summary, decisions, errors, patterns);

  // Save digest (skip if dry-run)
  if (dryRun) {
    console.log('\n[DRY RUN] Would generate:\n');
    console.log(digest);
    console.log('\n[DRY RUN] No files saved.');
    return { entries, decisions, errors, patterns, summary, digest };
  }

  // Save digest to file
  const digestPath = path.join(PATHS.digests, `${date}.md`);
  fs.writeFileSync(digestPath, digest);
  console.log(`âœ… Saved digest: ${digestPath}`);

  // Update indexes
  await updateDecisionsIndex(decisions, date);
  await updateLearningMetrics(entries, patterns, date);
  console.log('âœ… Updated indexes and metrics');

  console.log('\n' + 'â”€'.repeat(50));
  console.log('Digest complete!\n');
}

// CLI
const args = process.argv.slice(2);
const options = {};

args.forEach(arg => {
  if (arg.startsWith('--')) {
    const [key, value] = arg.slice(2).split('=');
    options[key.replace(/-/g, '')] = value || true;
  }
});

if (args.includes('--help') || args.includes('-h')) {
  console.log(`
Daily Digest - Batch processing of activity logs

Usage:
  node daily-digest.mjs [options]

Options:
  --date=YYYY-MM-DD   Process specific date (default: today)
  --dry-run           Preview without saving
  --help              Show this help

What it does:
  1. Loads activity log for the date
  2. Extracts decisions (auto-detected + tagged)
  3. Extracts error patterns
  4. Detects repetition patterns
  5. Generates summary (Ollama local = â‚¬0, or deterministic fallback)
  6. Saves digest to .aios/logs/digests/
  7. Updates memory indexes and learning metrics

Cost: â‚¬0 (uses Ollama local or deterministic processing)
`);
  process.exit(0);
}

run(options);
